 --6-1 서브쿼리, 세미조인, 안티조인
 
--메인 쿼리와 서브쿼리가 합쳐져 한 문장을 이룸
--서브 쿼리는 하나의 SELECT 문장으로,괄호로 둘러싸인 형태
 
--서브쿼리 위치에 따라~ 스칼라 서브쿼리, 인라인 뷰, 중첩 서브쿼리
 
--스칼라 서브 쿼리
--서브쿼리가 최종 반환하는 로우 수는 1개

SELECT A.EMPLOYEE_ID,A.FIRST_NAME||''||A.LAST_NAME,A.DEPARTMENT_ID, (SELECT B.DEPARTMENT_NAME,  FROM DEPARTMENTS B WHERE A.DEPARTMENT_ID=B.DEPARTMENT_ID) DEPT_NAME
FROM EMPLOYEES A
ORDER BY 1;

--JOIN이 없을 때 오류
SELECT A.EMPLOYEE_ID,A.FIRST_NAME||''||A.LAST_NAME,A.DEPARTMENT_ID, (SELECT B.DEPARTMENT_NAME FROM DEPARTMENTS B) DEPT_NAME
FROM EMPLOYEES A
ORDER BY 1;

--두개의 컬럼 값을 가져오므로 오류
SELECT A.EMPLOYEE_ID,A.FIRST_NAME||''||A.LAST_NAME,A.DEPARTMENT_ID, (SELECT B.DEPARTMENT_NAME,B.LOCATION_ID FROM DEPARTMENTS B  WHERE A.DEPARTMENT_ID=B.DEPARTMENT_ID) DEPT_NAME
FROM EMPLOYEES A
ORDER BY 1;

--JOB_TITLE,JOB_ID 두 컬럼을 사용하지만, 문자열 연결 연산자로 결합되어 최종 반환 값은 1개
SELECT A.EMPLOYEE_ID,A.FIRST_NAME||''||A.LAST_NAME,A.DEPARTMENT_ID, (SELECT B.JOB_TITLE||'('||B.JOB_ID||')' FROM JOBS B  WHERE A.JOB_ID=B.JOB_ID) JOB_NAME
FROM EMPLOYEES A
ORDER BY 1;

--스칼라 서브쿼리는 성능상 좋지않음

--인라인 뷰

--서브 쿼리 내에서 조인 조건 불가능
SELECT A.EMPLOYEE_ID, A.FIRST_NAME||''||A.LAST_NAME,A.DEPARTMENT_ID,C.DEPT_NAME
FROM EMPLOYEES A, (SELECT B.DEPARTMENT_ID,B.DEPARTMENT_NAME DEPT_NAME FROM DEPARTMENTS B WHERE A.DEPARTMENT_ID=B.DEPARTMENT_ID) C
ORDER BY 1;

--LATERAL 사용해 서브 쿼리 내에서 조인 가능
SELECT A.EMPLOYEE_ID, A.FIRST_NAME||''||A.LAST_NAME,A.DEPARTMENT_ID,C.DEPT_NAME
FROM EMPLOYEES A, LATERAL(SELECT B.DEPARTMENT_ID,B.DEPARTMENT_NAME DEPT_NAME FROM DEPARTMENTS B WHERE A.DEPARTMENT_ID=B.DEPARTMENT_ID) C
ORDER BY 1;

SELECT A.EMPLOYEE_ID, A.FIRST_NAME||''||A.LAST_NAME, DEPT.DEPARTMENT_NAME, LOC.STREET_ADDRESS, LOC.CITY, LOC.COUNTRY_NAME
FROM EMPLOYEES A, LATERAL(SELECT * FROM DEPARTMENTS B WHERE A.DEPARTMENT_ID=B.DEPARTMENT_ID) DEPT, LATERAL(SELECT L.LOCATION_ID, L.STREET_ADDRESS, L.CITY, C.COUNTRY_NAME FROM LOCATIONS L,COUNTRIES C WHERE C.COUNTRY_ID=.L.COUNTRY_ID) LOC
ORDER BY 1;

--부서별 평균 급여를 서브쿼리에서 구한 뒤 사원 급여와 부서 평균 급여를 같이 조회

SELECT *
FROM DEPARTMENTS;
SELECT *
FROM EMPLOYEES;

SELECT B.DEPARTMENT_ID, B.EMPLOYEE_ID,B.LAST_NAME, B.SALARY, A.AVG_SALARY
FROM EMPLOYEES B, (SELECT A.DEPARTMENT_ID,AVG(A.SALARY) AVG_SALARY FROM EMPLOYEES A GROUP BY A.DEPARTMENT_ID) A
WHERE B.DEPARTMENT_ID=A.DEPARTMENT_ID
ORDER BY B.DEPARTMENT_ID;

--중첩 서브쿼리

--메인 쿼리의 WHERE 절에 위치
SELECT *
FROM DEPARTMENTS
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES);

--급여가 10000 초과인 사원이 속한 부서 정보 조회
--EXITS 연산자는 존재하는지를 체크
SELECT *
FROM DEPARTMENTS A
WHERE EXISTS(SELECT 'A' FROM EMPLOYEES B WHERE A.DEPARTMENT_ID=B.DEPARTMENT_ID AND B.SALARY>10000);

--JOB_ID별 최소 급여를 받는 사원 조회
SELECT EMPLOYEE_ID,FIRST_NAME||''||LAST_NAME, JOB_ID,SALARY
FROM EMPLOYEES
WHERE (JOB_ID,SALARY) IN (SELECT JOB_ID,MIN_SALARY FROM JOBS)
ORDER BY 1;

--PATABALLA란 사원의 SALARY와 COMMISSION_PCT 합보다 큰 사원 조회
SELECT LAST_NAME, EMPLOYEE_ID,SALARY+NVL(COMMISSION_PCT,0),JOB_ID,A.DEPARTMENT_ID
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID=B.DEPARTMENT_ID
AND SALARY+NVL(COMMISSION_PCT,0)> (SELECT SALARY+NVL(COMMISSION_PCT,0) FROM EMPLOYEES WHERE LAST_NAME='Pataballa')
ORDER BY LAST_NAME,EMPLOYEE_ID;

--
SELECT DEPARTMENT_ID,EMPLOYEE_ID,LAST_NAME,SALARY
FROM EMPLOYEES A
WHERE SALARY >(SELECT AVG(SALARY) FROM EMPLOYEES B WHERE A.DEPARTMENT_ID=B.DEPARTMENT_ID)
ORDER BY DEPARTMENT_ID;

--안티 조인
--세미 조인에서 NOT 연산자 사용하는 조인
SELECT *
FROM DEPARTMENTS A
WHERE NOT EXISTS (SELECT 1 FROM EMPLOYEES B WHERE A.DEPARTMENT_ID=B.DEPARTMENT_ID);

--직급 변경이 없는 사원만 조회
SELECT A.EMPLOYEE_ID, A.FIRST_NAME||''||A.LAST_NAME
FROM EMPLOYEES A
WHERE A.EMPLOYEE_ID NOT IN (SELECT B.EMPLOYEE_ID FROM JOB_HISTORY B);

