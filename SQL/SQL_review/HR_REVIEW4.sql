--4.1 집계쿼리-집계함수와 GROUPBY절

--COUNT: 전체갯수 반환
--MAX: 최댓값 반환
--MIN: 최소값 반환
--SUM: 합계반환
--AVG: 평균값 반환
--VARIANCE: 분산 반환
--STDDEV: 표준편차 반환

SELECT EMPLOYEE_ID
FROM EMPLOYEES
GROUP BY EMPLOYEE_ID;

SELECT EMPLOYEE_ID,JOB_ID
FROM EMPLOYEES
ORDER BY 2;

SELECT JOB_ID
FROM EMPLOYEES
GROUP BY JOB_ID;
--유일한 JOB_ID 컬럼 값 수로 로우 수가 줄어든다.

SELECT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR
FROM EMPLOYEES
GROUP BY TO_CHAR(HIRE_DATE,'YYYY');
--SELECT 절에 기술한 형태 그대로 사용해야 된다.

SELECT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR
FROM EMPLOYEES
GROUP BY  HIRE_DATE;
--입사년도가 아닌 입사일자별로 집계되었다.

SELECT COUNT(*)
FROM EMPLOYEES;

SELECT COUNT(*) TOTAL_CNT, MIN(SALARY) MIN_SALARY, MAX(SALARY) MAX_SALARY
FROM EMPLOYEES;
-- EMPLOYES 테이블의 전체 로우 건수


SELECT JOB_ID,COUNT(*) TOTAL_CNT,MIN(SALARY) MIN_SALARY, MAX(SALARY) MAX_SALARY
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;
--EMPLOYEES 테이블의 JOB_ID별 건수, SALARY 컬럼의 최소와 최댓값


SELECT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR, DEPARTMENT_ID,COUNT(*), SUM(SALARY),AVG(SALARY)
FROM EMPLOYEES
GROUP BY TO_CHAR(HIRE_DATE,'YYYY'),DEPARTMENT_ID
ORDER BY 1,2;
-- 입사년도와 부서별 총인원수와 급여 총액, 급여 평균

SELECT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR, DEPARTMENT_ID,COUNT(*), SUM(SALARY),AVG(SALARY)
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'YYYY')>='2004'
GROUP BY TO_CHAR(HIRE_DATE,'YYYY'),DEPARTMENT_ID
ORDER BY 1,2;
--2004년 이후 입사 년도와 부서별 총 인원수와 급여 총액, 급여 평균

SELECT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR, DEPARTMENT_ID,COUNT(*), SUM(SALARY),ROUND(AVG(SALARY),0)
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'YYYY')>='2004'
GROUP BY TO_CHAR(HIRE_DATE,'YYYY'),DEPARTMENT_ID
ORDER BY 1,2;
--ROUND 함수를 통해 급여 평균 값의 소수점 제거

SELECT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR, DEPARTMENT_ID,COUNT(*), SUM(SALARY),ROUND(AVG(SALARY),0)
FROM EMPLOYEES
WHERE ROUND(AVG(SALARY),0)>=5000
GROUP BY TO_CHAR(HIRE_DATE,'YYYY'),DEPARTMENT_ID
ORDER BY 1,2;
--그룹 함수는 WHERE 절에서 사용 불가~HAVING 절 이용

SELECT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR, DEPARTMENT_ID,COUNT(*), SUM(SALARY),ROUND(AVG(SALARY),0)
FROM EMPLOYEES
GROUP BY TO_CHAR(HIRE_DATE,'YYYY'),DEPARTMENT_ID
HAVING ROUND(AVG(SALARY),0)>=5000
ORDER BY 1,2;
--HAVING 절은 GROUP BY 와 ORDER BY 사이에 존재

SELECT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR, DEPARTMENT_ID,COUNT(*), SUM(SALARY),ROUND(AVG(SALARY),0)
FROM EMPLOYEES
GROUP BY TO_CHAR(HIRE_DATE,'YYYY'),DEPARTMENT_ID
HAVING COUNT(*)>1
ORDER BY 1,2;


SELECT JOB_ID
FROM EMPLOYEES
GROUP BY JOB_ID;
-- 서로 같다.
SELECT DISTINCT JOB_ID
FROM EMPLOYEES;
--DISTINCT의 다른점은 두개 합쳐서 고유값이 나온다.

SELECT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR, DEPARTMENT_ID
FROM EMPLOYEES
GROUP BY TO_CHAR(HIRE_DATE,'YYYY'), DEPARTMENT_ID
ORDER BY 1,2;

SELECT DISTINCT TO_CHAR(HIRE_DATE,'YYYY') HIRE_YEAR, DEPARTMENT_ID
FROM EMPLOYEES
ORDER BY 1,2;

--ROLLUP: 소계
--CUBE: 모든 가능한 조합에 대한 소계

--ROLLUP
SELECT SUBSTR(PHONE_NUMBER,1,3), JOB_ID,SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID, SUBSTR(PHONE_NUMBER,1,3)
ORDER BY 1,2;

--CUBE
SELECT SUBSTR(PHONE_NUMBER,1,3), JOB_ID,SUM(SALARY)
FROM EMPLOYEES
GROUP BY CUBE(JOB_ID, SUBSTR(PHONE_NUMBER,1,3))
ORDER BY 1,2;

--ROLLUP
SELECT SUBSTR(PHONE_NUMBER,1,3), JOB_ID,SUM(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID, SUBSTR(PHONE_NUMBER,1,3))
ORDER BY 1,2;

--4.2 집합 쿼리- 집합 연산자

--순서 
--SELECT
--FROM
--집합연산자~UNION, UNION ALL, INTERSECT,MINUS 4개 연산자 존재
--ORDER BY는 SELECT 문장에서만 붙일수있음

--UNION: 합집합
SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 2000 AND 5000

UNION 

SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 5001 AND 6000
ORDER BY JOB_ID;
--SELECT이후에 오는 컬럼수가 똑같고, 데이터 형도 일치해야 된다.
-- A UNION B 면 A기준으로 컬럼명 생성!!!


--UNION ALL: 중복값도 모두 조회

SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 2000 AND 5000

UNION ALL

SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 5001 AND 6000
ORDER BY JOB_ID;


--INTERSECT: 교집합
SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 2000 AND 5000

INTERSECT

SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 5001 AND 6000
ORDER BY JOB_ID;

-- MINUS: 차집합
SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 2000 AND 5000
MINUS
SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 5001 AND 6000
ORDER BY JOB_ID;



SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 5001 AND 6000
MINUS
SELECT JOB_ID
FROM EMPLOYEES
WHERE 1=1
AND SALARY BETWEEN 2000 AND 5000
ORDER BY JOB_ID;


